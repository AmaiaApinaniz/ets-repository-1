<?xml version="1.0" encoding="utf-8"?>
<ExecutableTestSuite xmlns="http://www.interactive-instruments.de/etf/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="EID09820daf-62b2-4fa3-a95f-56a0d2b7c4d8" xsi:schemaLocation="http://www.interactive-instruments.de/etf/2.0 ../../schema/td/testDriverResponse.xsd">
	<remoteResource>http://github.com/inspire-eu-validation/ets-repository/data/schemas</remoteResource>
	<label>Conformance class: INSPIRE GML application schemas, General requirements</label>
	<description><![CDATA[This test suite examines GML documents against basic requirements for the GML encoding for spatial data sets in INSPIRE. This only covers application-schema-independent, generic requirements. Requirements related to specific application schemas are part of conformance classes with a dependency on this conformance class.<br/><br/>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-encoding/3.3/inspire-gml" target="_blank">Conformance Class 'INSPIRE GML encoding'</a><br/><br/>
Pre-requisite conformance classes:
<ul><li><a href="http://inspire.ec.europa.eu/id/ats/data-encoding/3.3/inspire-gml" target="_blank">Conformance Class 'INSPIRE GML encoding'</a></li></ul>]]></description>
	<version>0.1.0</version>
	<author>interactive instruments GmbH</author>
	<creationDate>2016-08-15T00:00:00Z</creationDate>
	<lastEditor>interactive instruments GmbH</lastEditor>
	<lastUpdateDate>2016-08-15T00:00:00Z</lastUpdateDate>
	<translationTemplateBundle ref="EID70a263c0-0ad7-42f2-9d4d-0d8a4ca71b52"/>
	<ParameterList name="ETF Standard Parameters for XML test objects">
		<parameter name="files_to_test" required="true">
			<defaultValue>.*</defaultValue>
			<description ref="TR.filesToTest"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
		<parameter name="tests_to_execute" required="false">
			<defaultValue>.*</defaultValue>
			<description ref="TR.testsToExecute"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
	</ParameterList>
	<supportedTestObjectTypes>
		<testObjectType ref="EIDe1d4a306-7a78-4a3b-ae2d-cf5f0810853e"/>
	</supportedTestObjectTypes>
	<dependencies>
		<executableTestSuite ref="EID545f9e49-009b-4114-9333-7ca26413b5d4"/>
	</dependencies>
	<testModules>
		<TestModule id="EID073b8871-8ce0-4ba8-9b53-f1aec2019d3b">
			<label>IGNORE</label>
			<description>IGNORE</description>
			<parent ref="EID09820daf-62b2-4fa3-a95f-56a0d2b7c4d8"/>
			<testCases>
				<TestCase id="EID071a80e9-332e-4219-b600-329f47b98ef1">
					<label>Schema</label>
					<description>Verify whether each relevant element of the dataset under inspection carries a name specified in the target application schema.</description>
					<parent ref="EID073b8871-8ce0-4ba8-9b53-f1aec2019d3b"/>
					<testSteps>
						<TestStep id="EID871889b6-5664-4498-8762-849fb77a084f">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID071a80e9-332e-4219-b600-329f47b98ef1"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID09ad14e3-d46f-42fc-9b01-64cb6ed2134c">
									<label>gmlas.a.1: Mapping of source data to INSPIRE</label>
									<description><![CDATA[Verify whether each relevant element of the source data set under inspection has been properly mapped to the INSPIRE application schemas. Inspect the documentation of the source data set and determine, if all relevant information has been mapped correctly to the INSPIRE application schema, i.e. that spatial object types, data types, attributes, association roles, code lists, and enumerations are mapped to the INSPIRE application schemas with the correct designation of mnemonic names.<br/><br/>
Relevant requirements:
<ul><li>Article 4(1) - For the exchange and classification of spatial objects from data sets meeting the conditions laid down in Article 4 of Directive 2007/2/EC, Member States shall use the spatial object types and associated data types, enumerations and code lists that are defined in Annexes II, III and IV for the themes the data sets relate to.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Schema'</a>]]></description>
									<parent ref="EID871889b6-5664-4498-8762-849fb77a084f"/>
									<expectedResult/>
									<expression/>
									<testItemType ref="EIDb48eeaa3-6a74-414a-879c-1dc708017e11"/>
								</TestAssertion>
								<TestAssertion id="EIDa24f1604-1e86-43d7-b1b0-47ede44b4f9c">
									<label>gmlas.a.2: Modelling of additional spatial object types</label>
									<description><![CDATA[Inspect the XML Schema namespace of each feature element. If a namespace URI does not start with "http://inspire.ec.europa.eu/schemas/" or "urn:x-inspire:specification:gmlas:" it is not one of the approved INSPIRE application schema namespaces. Review the extension documentation for the identified namespaces to check that any extensions do not overlap with the spatial object types and associated data types and enumerations that are defined in Annexes II, III and IV of the Implementing Rule.<br/><br/>
Relevant requirements:
<ul><li>Article 4(1) - For the exchange and classification of spatial objects from data sets meeting the conditions laid down in Article 4 of Directive 2007/2/EC, Member States shall use the spatial object types and associated data types, enumerations and code lists that are defined in Annexes II, III and IV for the themes the data sets relate to.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Schema'</a>]]></description>
									<parent ref="EID871889b6-5664-4498-8762-849fb77a084f"/>
									<expectedResult/>
									<expression/>
									<testItemType ref="EIDb48eeaa3-6a74-414a-879c-1dc708017e11"/>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID2c6fe882-7c53-47f2-b4c4-66b15c248be4">
					<label>Schema validation</label>
					<description>Verify that all XML documents validate against their XML schema(s).</description>
					<parent ref="EID073b8871-8ce0-4ba8-9b53-f1aec2019d3b"/>
					<testSteps>
						<TestStep id="EID77f090cf-48ef-46f3-901b-6ef2db4a1599">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID2c6fe882-7c53-47f2-b4c4-66b15c248be4"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID40646a32-7b85-411f-abc7-1eba528d7d95">
									<label>gmlas.b.1: xsi:schemaLocation attribute</label>
									<description><![CDATA[Verify for each XML document that the xsi:schemaLocation attribute is provided in the root element.<br/><br/>
Relevant requirements:
<ul>
<li>TG Requirement 6: Data instance (XML) documents shall validate without error against the provided XML schema.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Schema validation'</a>]]></description>
									<parent ref="EID77f090cf-48ef-46f3-901b-6ef2db4a1599"/>
									<expectedResult/>
									<expression>
let $filesWithErrors := $db[not(/*/@xsi:schemaLocation)][position() le $limitErrors]
return
(if ($filesWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.filesWithErrors', count($filesWithErrors)),
 for $file in $filesWithErrors
    order by local:filename($file)
    let $root := $file/element()
    return
     local:addMessage('TR.noSchemaLocation', map { 'filename': local:filename($root) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noSchemaLocation"/>
										<translationTemplate ref="TR.filesWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID0eaac0f2-9ab3-44ab-9f02-4ee0a1587d14">
									<label>gmlas.b.2: validate XML documents</label>
									<description><![CDATA[Validate each document against the schema(s) specified in the xsi:schemaLocation attribute using strict XML schema validation.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Article 3: Common Types. Types that are common to several of the themes listed in Annexes I, II and III to Directive 2007/2/EC shall conform to the definitions and constraints and include the attributes and association roles set out in Annex I.</li>
<li>IR Requirement Article 4 (2): Types for the Exchange and Classification of Spatial Objects. Spatial object types and data types shall comply with the definitions and constraints and include the attributes and association roles set out in the Annexes.</li>
<li>IR Requirement Article 4 (3): Types for the Exchange and Classification of Spatial Objects. The enumerations and code lists used in attributes or association roles of spatial object types or data types shall comply with the definitions and include the values set out in Annex II. The enumeration and code list values are uniquely identified by language-neutral mnemonic codes for computers. The values may also include a language-specific name to be used for human interaction.</li>
<li>IR Requirement Article 5 (2): Types. Types that are a sub-type of another type shall also include all this typeâ€˜s attributes and association roles.</li>
<li>IR Requirement Article 5 (3): Types. Abstract types shall not be instantiated.</li>
<li>IR Requirement Article 6 (5): Code Lists and Enumerations. Attributes or association roles of spatial object types or data types that have an enumeration type may only take values from the lists specified for the enumeration type.</li>
<li>IR Requirement Article 9 (1): Identifier Management. The data type Identifier defined in Section 2.1 of Annex I shall be used as a type for the external object identifier of a spatial object.</li>
<li>TG Requirement 1: Spatial object types and data types shall comply with the multiplicities defined for the attributes and association roles in this section.</li>
<li>TG Requirement 6: Data instance (XML) documents shall validate without error against the provided XML schema.</li>
</ul>
Source: <a href="" target="_blank">Abstract Test Case 'Schema validation'</a>]]></description>
									<parent ref="EID77f090cf-48ef-46f3-901b-6ef2db4a1599"/>
									<expectedResult/>
									<expression>
let $errors := (for $file in $db
  let $start := prof:current-ms()
  let $root := $file/element()
  let $messages := validate:xsd-info($file)
  let $duration := prof:current-ms()-$start
  let $logentry := local:log('Validating ' || local:filename($root)) || ': ' || $duration || ' ms')
  let $errors := count($messages)
  return
   if ($errors&gt;0) then
    (local:addMessage('TR.invalidSchema', map { 'filename': local:filename($root), 'count': string($errors) }),
     for $message in $messages return local:addMessage('TR.xmlSchemaError', map { 'filename': local:filename($root), 'error': $message }))
   else ())[position() le $limitErrors]						 
return
(if ($errors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.filesWithErrors', count($errors[@ref eq 'TR.invalidSchema'])),
 $errors[position() le $limitErrors])
									</expression>
									<testItemType ref="EID92f22a19-2ec2-43f0-8971-c2da3eaafcd2"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidSchema"/>
										<translationTemplate ref="TR.filesWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID18099150-f7ac-4174-a7b6-45121383a5d3">
					<label>GML model</label>
					<description>Verify that the XML documents meet the requirements of the GML model that are not tested by XML schema validation alone.</description>
					<parent ref="EID073b8871-8ce0-4ba8-9b53-f1aec2019d3b"/>
					<testSteps>
						<TestStep id="EIDc04ade3c-0ad2-4fa5-9977-d83022855e3b">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID18099150-f7ac-4174-a7b6-45121383a5d3"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDb33aaf9a-898f-4625-b87f-81c07ac09adf">
									<label>gmlas.c.1: Consistency with the GML model</label>
									<description><![CDATA[Inspect each property element and verify that it either carries a URI reference to an object (@xlink:href) that can be retrieved using HTTP GET, contains one or more object elements as child elements or contains a non-empty text node (whitespace is trimmed before checking for empty text).<br/><br/>
Strictly, empty string values are valid according to the GML model, but they are not an appropriate value for any of the string-valued attributes in INSPIRE.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Article 4 (2): Types for the Exchange and Classification of Spatial Objects. Spatial object types and data types shall comply with the definitions and constraints and include the attributes and association roles set out in the Annexes.</li>
<li>IR Requirement Article 4 (3): Types for the Exchange and Classification of Spatial Objects. The enumerations and code lists used in attributes or association roles of spatial object types or data types shall comply with the definitions and include the values set out in Annex II. The enumeration and code list values are uniquely identified by language-neutral mnemonic codes for computers. The values may also include a language-specific name to be used for human interaction.</li>
</ul>
Source: <a href="" target="_blank">Abstract Test Case 'GML model'</a>]]></description>
									<parent ref="EIDc04ade3c-0ad2-4fa5-9977-d83022855e3b"/>
									<expectedResult/>
									<expression>
let $featuresWithErrors := $features[*[not(@xlink:href or element() or (text() and string-length(normalize-space(text()))&gt;0) or @xsi:nil eq 'true')]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $properties := $feature/*[not(@xlink:href or element() or (text() and string-length(normalize-space(text()))&gt;0) or @xsi:nil eq 'true')]
   return
     local:addMessage('TR.emptyValue', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'propertyNames': fn:string-join($properties/local-name(),', ') }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.emptyValue"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDb62f96a5-349f-40dd-b777-1e52ea09b686">
									<label>gmlas.c.2: nilReason attributes require xsi:nil=true</label>
									<description><![CDATA[Inspect each XML element that represents a feature property and that has a nilReason XML attribute. Verify that xsi:nil='true' is present in the property element, i.e. a reason is only provided in properties that are void / nil.<br/><br/>
Limitation: This test currently does not analyse properties of data types or objects embedded in a feature.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Article 4 (2): Types for the Exchange and Classification of Spatial Objects. Spatial object types and data types shall comply with the definitions and constraints and include the attributes and association roles set out in the Annexes.</li>
<li>IR Requirement Article 4 (3): Types for the Exchange and Classification of Spatial Objects. The enumerations and code lists used in attributes or association roles of spatial object types or data types shall comply with the definitions and include the values set out in Annex II. The enumeration and code list values are uniquely identified by language-neutral mnemonic codes for computers. The values may also include a language-specific name to be used for human interaction.</li>
</ul>
Source: <a href="" target="_blank">Abstract Test Case 'GML model'</a>]]></description>
									<parent ref="EIDc04ade3c-0ad2-4fa5-9977-d83022855e3b"/>
									<expectedResult/>
									<expression>
let $featuresWithErrors := $features[*[@nilReason and not(@xsi:nil eq 'true')]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $properties := $feature/*[@nilReason and not(@xsi:nil eq 'true')]
   return
     local:addMessage('TR.nilMissing', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'propertyNames': fn:string-join($properties/local-name(),', ') }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.nilMissing"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDabc9199e-d5a8-4829-80bd-09b7e49e2a76">
									<label>gmlas.c.3: nilReason values</label>
									<description><![CDATA[Inspect all nilReason values and verify that either the values from the INSPIRE registry or the pre-defined values from the GML standard are used. Otherwise report incorrectReason. Valid values are:
<ul>
<li>'http://inspire.ec.europa.eu/codelist/VoidReasonValue/Unknown'</li>
<li>'http://inspire.ec.europa.eu/codelist/VoidReasonValue/Unpopulated'</li>
<li>'http://inspire.ec.europa.eu/codelist/VoidReasonValue/Withheld'</li>
<li>'unknown'</li>
<li>'other:unpopulated'</li>
<li>'withheld'</li>
</ul>
Limitation: This test currently does not analyse properties of data types or objects embedded in a feature.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Article 4 (2): Types for the Exchange and Classification of Spatial Objects. Spatial object types and data types shall comply with the definitions and constraints and include the attributes and association roles set out in the Annexes.</li>
<li>IR Requirement Article 4 (3): Types for the Exchange and Classification of Spatial Objects. The enumerations and code lists used in attributes or association roles of spatial object types or data types shall comply with the definitions and include the values set out in Annex II. The enumeration and code list values are uniquely identified by language-neutral mnemonic codes for computers. The values may also include a language-specific name to be used for human interaction.</li>
</ul>
Source: <a href="" target="_blank">Abstract Test Case 'GML model'</a>]]></description>
									<parent ref="EIDc04ade3c-0ad2-4fa5-9977-d83022855e3b"/>
									<expectedResult/>
									<expression>
let $values := ( 'http://inspire.ec.europa.eu/codelist/VoidReasonValue/Unknown', 'http://inspire.ec.europa.eu/codelist/VoidReasonValue/Unpopulated', 'http://inspire.ec.europa.eu/codelist/VoidReasonValue/Withheld', 'unknown', 'other:unpopulated', 'withheld' )
let $featuresWithErrors := $features[*[@xsi:nil eq 'true' and not(@nilReason =  $values)]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $properties := $feature/*[@xsi:nil eq 'true' and not(@nilReason =  $values)]
   let $values := distinct-values($properties/@nilReason)
   return
     local:addMessage('TR.incorrectReason', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'propertyNames': fn:string-join($properties/local-name(),', '), 'values': fn:string-join($values, ', ') }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.incorrectReason"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID7e0765c8-c149-4cf2-956f-ca4db0e0ed94">
					<label>Simple features</label>
					<description>Verify that all features that are not excluded from the default requirement that geometries meet the requirements of the Simple Features standard fulfill the requirements.</description>
					<parent ref="EID073b8871-8ce0-4ba8-9b53-f1aec2019d3b"/>
					<testSteps>
						<TestStep id="EID73531400-70ac-4374-83fd-5df504d5cfba">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID7e0765c8-c149-4cf2-956f-ca4db0e0ed94"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDf625c820-71a1-41e2-afb2-11cdc7d5a01b">
									<label>gmlas.d.1: No spatial topology objects</label>
									<description><![CDATA[Verify that no spatial topology types are used, i.e. check that none of the GML object elements for spatial topology are used as child elements of a feature from the application schema.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//*[self::gml:Node|self::gml:Edge|self::gml:Face|self::gml:TopoSolid|self::gml:TopoPoint|self::gml:TopoCurve|self::gml:TopoSurface|self::gml:TopoVolume|self::gml:TopoComplex]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := $feature//*[self::gml:Node|self::gml:Edge|self::gml:Face|self::gml:TopoSolid|self::gml:TopoPoint|self::gml:TopoCurve|self::gml:TopoSurface|self::gml:TopoVolume|self::gml:TopoComplex][1]
   return
     local:addMessage('TR.spatialTopologyTypeFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.spatialTopologyTypeFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID44cf3e26-809e-49a9-8ec0-750a373e9ff1">
									<label>gmlas.d.2: No non-linear interpolation</label>
									<description><![CDATA[Verify that only linear interpolation is used, i.e. check that none of the nonlinear GML curve segment object elements are used as child elements of a feature from the application schema.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//gml:Curve/gml:segments/*[not(self::gml:LineStringSegment)]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := $feature//gml:Curve/gml:segments/*[not(self::gml:LineStringSegment)][1]
   return
     local:addMessage('TR.invalidInterpolationFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidInterpolationFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID3d7ad0b2-c9f5-4910-aa09-b3226b720f7d">
									<label>gmlas.d.3: Surface geometry elements</label>
									<description><![CDATA[Verify that only gml:Polygon or gml:Surface are used, i.e. check that none of the disallowed GML surface object elements are used as child elements of a feature from the application schema.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//*[self::gml:OrientableSurface|self::gml:CompositeSurface|self::gml:PolyhedralSurface|self::gml:Tin|self::gml:TriangulatedSurface]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := $feature//*[self::gml:OrientableSurface|self::gml:CompositeSurface|self::gml:PolyhedralSurface|self::gml:Tin|self::gml:TriangulatedSurface][1]
   return
     local:addMessage('TR.invalidSurfaceElementFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidSurfaceElementFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID008b7c4f-b315-4596-b5e9-4a29910eb43f">
									<label>gmlas.d.4: No non-planar interpolation</label>
									<description><![CDATA[Verify that only planar interpolation is used, i.e. check that only PolygonPatch is used as a GML surface patch object elements in features from the application schema.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//gml:Surface/gml:patches/*[not(self::gml:PolygonPatch)]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := $feature//gml:Surface/gml:patches/*[not(self::gml:PolygonPatch)][1]
   return
     local:addMessage('TR.invalidSurfacePatchElementFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidSurfacePatchElementFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID4f2f9722-897a-4bad-b11e-d4e119b6690d">
									<label>gmlas.d.5: Geometry elements</label>
									<description><![CDATA[Verify that only valid GML geometry elements are used, i.e. check that none of the disallowed GML geometry object elements are used as child elements of a feature from the application schema.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//*[self::gml:Solid|self::gml:MultiSolid|self::gml:CompositeSolid|self::gml:CompositeCurve|self::gml:Grid]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := $feature//*[self::gml:Solid|self::gml:MultiSolid|self::gml:CompositeSolid|self::gml:CompositeCurve|self::gml:Grid][1]
   return
     local:addMessage('TR.invalidGeometryElementFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidGeometryElementFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDbc49770c-4eab-4330-8462-af0664ae0b80">
									<label>gmlas.d.6: Point coordinates in gml:pos</label>
									<description><![CDATA[Verify that in points only gml:pos is used for coordinates.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//gml:Point/*[not(self::gml:pos)]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := $feature//gml:Point/*[not(self::gml:pos)][1]
   return
     local:addMessage('TR.invalidPositionElementFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element), 'geometryType': 'point', 'posElementName': 'gml:pos' }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidPositionElementFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID894c6a96-4fb2-4921-ad98-1d2a52985887">
									<label>gmlas.d.7: Curve/Surface coordinates in gml:posList</label>
									<description><![CDATA[Verify that in curves and surfaces only gml:posList is used for coordinates.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//*[self::gml:LineString|self::gml:LineStringSegment|self::gml:LinearRing]/*[not(self::gml:posList)]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := ($feature//*[self::gml:LineString|self::gml:LineStringSegment|self::gml:LinearRing|self::gml:Arc|self::gml:Circle]/*[not(self::gml:posList)])[1]
   return
     local:addMessage('TR.invalidPositionElementFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element), 'geometryType': 'curve/surface', 'posElementName': 'gml:posList' }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidPositionElementFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID160e4f83-e9c3-45c5-b684-20027f8f191a">
									<label>gmlas.d.8: No array property elements</label>
									<description><![CDATA[Verify that geometry aggregates do not use the GML array property elements, i.e. check that the only the regular property elements are used, but not the array property elements. For example, for a gml:MultiPoint, only gml:pointMember may be used, not gml:pointMembers.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//*[self::gml:MultiPoint/gml:pointMembers|self::gml:MultiCurve/gml:curveMembers|self::gml:MultiSurface/gml:surfaceMembers|self::gml:MultiGeometry/gml:geometryMembers]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $element := ($feature//*[self::gml:MultiPoint|self::gml:MultiCurve|self::gml:MultiSurface|self::gml:MultiGeometry]/*[self::gml:pointMembers|self::gml:curveMembers|self::gml:surfaceMembers|self::gml:geometryMembers])[1]
   return
     local:addMessage('TR.arrayElementFound', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'elementName': name($element) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.arrayElementFound"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDf9e92525-152a-41fa-9990-42691f39b1ce">
									<label>gmlas.d.9: 1, 2 or 3 coordinate dimensions</label>
									<description><![CDATA[Coordinate reference systems may have 1, 2 or 3 dimensions, i.e. check all occurances of srsDimension and for values greater than '3'.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := $featuresToInspect[.//*[@srsDimension &gt; 3]][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   let $dimension := $feature//@srsDimension[. &gt; 3][1]
   return
     local:addMessage('TR.tooManyDimensions', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'dimension': string($dimension) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.tooManyDimensions"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID79aec969-3ca0-4190-a6e9-8b49682f414a">
									<label>gmlas.d.10: Validate geometries</label>
									<description><![CDATA[Verify that in curves and surfaces only gml:posList is used for coordinates, i.e. validate all geometry elements of a feature from the application schema using a geometry library.<br/><br/>
Relevant requirements:
<ul><li>IR Requirement Article 12 (1): Other Requirements and Rules. The value domain of spatial properties defined in this Regulation shall be restricted to the Simple Feature spatial schema as defined in Herring, John R. (ed.), OpenGISÂ® Implementation Standard for Geographic information â€“ Simple feature access â€“ Part 1: Common architecture, version 1.2.1, Open Geospatial Consortium, 2011, unless specified otherwise for a specific spatial data theme or type.</li></ul>
Source: <a href="" target="_blank">Abstract Test Case 'Simple features'</a>]]></description>
									<parent ref="EID73531400-70ac-4374-83fd-5df504d5cfba"/>
									<expectedResult/>
									<expression>
(: TODO: add other feature types to exclude; extend with subtypes :)
let $featuresToInspect := $features[not(self::*:CadastralParcel)]  
let $featuresWithErrors := for $feature in $featuresToInspect
  return
   if (contains(ggeo:validate($feature,'110'),'F')) then $feature else ()
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
   return
     local:addMessage('TR.invalidGeometry', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id) }))
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.invalidGeometry"/>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
			</testCases>
		</TestModule>
	</testModules>
</ExecutableTestSuite>
