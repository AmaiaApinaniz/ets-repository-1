<?xml version="1.0" encoding="utf-8"?>
<ExecutableTestSuite 
	xmlns="http://www.interactive-instruments.de/etf/2.0" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	id="EID59692c11-df86-49ad-be7f-94a1e1ddd8da" xsi:schemaLocation="http://www.interactive-instruments.de/etf/2.0 ../../schema/model/resultSet.xsd">
	<itemHash>bQ==</itemHash>
	<remoteResource>http://github.com/inspire-eu-validation/ets-repository/metadata/2.0</remoteResource>
	<localPath>/auto</localPath>
	<label>Common Requirements for ISO/TC 19139:2007 based INSPIRE metadata records.</label>
	<description>
		<![CDATA[<br/><br/><b>This is a draft version. It has limitations and is expected to contain errors.</b> Please report any issues or problems <a href="https://github.com/interactive-instruments/ets-repository/issues" target="_blank">in GitHub</a>.<br/><br/>
Known limitations are documented in the description of the applicable test case or test assertion.<br/><br/>
There is a general limitation in all assertions that polymorphism and containment by reference (see the <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/README#ref_TG_MD" target="_blank">Technical Guidance</a>, sub-clauses A.3, A.4 and A.5) are not supported. However, the current Abstract Test Suite does not support polymorphism and references either (all XPath expressions do not support polymorhism or references; in addition, schema validation is only executed against the ISO/OGC schemas without extensions). It is therefore unclear if this is really a limitation or if the sections in the technical guidance are outdated.
<br/><br/>
Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common" target="_blank">Common Requirements for ISO/TC 19139:2007 based INSPIRE metadata records</a><br/><br/>]]>
	</description>
	<reference>../../../inspire-md-bsxets.xq</reference>
		<version>0.1.0</version>
	<author>Consortium Bilbomatica, Guadaltel y Geograma</author>
	<creationDate>2018-06-30T00:00:00Z</creationDate>
	<lastEditor>Consortium Bilbomatica, Guadaltel y Geograma</lastEditor>
	<lastUpdateDate>2018-08-30T20:45:00Z</lastUpdateDate>
	<tags>
		<tag ref="EIDc6567beb-fc33-4f2e-865d-0c3ee5b3d1ae"/>
	</tags>
	<testDriver ref="EID4dddc9e2-1b21-40b7-af70-6a2d156ad130"/>
	<translationTemplateBundle ref="EID70a263c0-0ad7-42f2-9d4d-0d8a4ca71b52"/>
	<ParameterList name="ETF Standard Parameters for metadata XML test objects">
		<!-- TODO clean up, currently disabled due to open issues with schema validation
		<parameter name="encoding" required="false"><defaultValue>CSW ISO AP 1.0.0</defaultValue><description ref="TR.metadataEncoding"/><allowedValues>^(CSW ISO AP 1\.0\.0|ISO/TS 19139)$</allowedValues><type>string</type></parameter><parameter name="Schema_file" required="false"><description ref="TR.metadataSchema"/><allowedValues>^(apiso\.xsd|gmd\.xsd|apiso-csw\.xsd|gmd-csw\.xsd)?$</allowedValues><type>string</type></parameter>
		-->
		<parameter name="files_to_test" required="true">
			<defaultValue>.*</defaultValue>
			<description ref="TR.filesToTest"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
		<parameter name="tests_to_execute" required="false">
			<defaultValue>.*</defaultValue>
			<description ref="TR.testsToExecute"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
	</ParameterList>
	<supportedTestObjectTypes>
		<testObjectType ref="EID5a60dded-0cb0-4977-9b06-16c6c2321d2e"/>
	</supportedTestObjectTypes>
	<testModules>
		<TestModule id="EID137a11bc-4f87-4a55-ab71-59d03e6b28da">
			<label>IGNORE</label>
			<description>IGNORE</description>
			<parent ref="EID59692c11-df86-49ad-be7f-94a1e1ddd8da"/>
			<testCases>
				<TestCase id="EID61e7ffc0-c181-11e8-a355-529269fb1459">
					<label>General requirements</label>
					<description>Execute tests that apply for all metadata records on elements that are directly child elements of the root node of the XML document: MD_Metadata node.
					</description>
					<parent ref="EID137a11bc-4f87-4a55-ab71-59d03e6b28da"/>
					<testSteps>
						<TestStep id="EID61e80506-c181-11e8-a355-529269fb1459">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID61e7ffc0-c181-11e8-a355-529269fb1459"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDebdda4b4-0bb4-4255-a36a-db4fe540065c">
									<label>md common req C.5: Language Code</label>
									<description><![CDATA[<p>Test that a resource language is given pointing to one of the official languages of the Community expressed in conformity with ISO 639-2</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/metadata-language-code" target="_blank">Metadata Language</a></p>]]></description>
									<parent ref="EID61e80506-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
									let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = ('dataset','series','service')]
									let $codes := ('aar','abk','ace','ach','ada','ady','afa','afh','afr','ain','aka','akk','alb','ale','alg','alt','amh','ang','anp','apa','ara','arc','arg','arm','arn','arp','art','arw','asm','ast','ath','aus','ava','ave','awa','aym','aze','bad','bai','bak','bal','bam','ban','baq','bas','bat','bej','bel','bem','ben','ber','bho','bih','bik','bin','bis','bla','bnt','bos','bra','bre','btk','bua','bug','bul','bur','byn','cad','cai','car','cat','cau','ceb','cel','cha','chb','che','chg','chi','chk','chm','chn','cho','chp','chr','chu','chv','chy','cmc','cop','cor','cos','cpe','cpf','cpp','cre','crh','crp','csb','cus','cze','dak','dan','dar','day','del','den','dgr','din','div','doi','dra','dsb','dua','dum','dut','dyu','dzo','efi','egy','eka','elx','eng','enm','epo','est','ewe','ewo','fan','fao','fat','fij','fil','fin','fiu','fon','fre','frm','fro','frr','frs','fry','ful','fur','gaa','gay','gba','gem','geo','ger','gez','gil','gla','gle','glg','glv','gmh','goh','gon','gor','got','grb','grc','gre','grn','gsw','guj','gwi','hai','hat','hau','haw','heb','her','hil','him','hin','hit','hmn','hmo','hrv','hsb','hun','hup','iba','ibo','ice','ido','iii','ijo','iku','ile','ilo','ina','inc','ind','ine','inh','ipk','ira','iro','ita','jav','jbo','jpn','jpr','jrb','kaa','kab','kac','kal','kam','kan','kar','kas','kau','kaw','kaz','kbd','kha','khi','khm','kho','kik','kin','kir','kmb','kok','kom','kon','kor','kos','kpe','krc','krl','kro','kru','kua','kum','kur','kut','lad','lah','lam','lao','lat','lav','lez','lim','lin','lit','lol','loz','ltz','lua','lub','lug','lui','lun','luo','lus','mac','mad','mag','mah','mai','mak','mal','man','mao','map','mar','mas','may','mdf','mdr','men','mga','mic','min','mis','mkh','mlg','mlt','mnc','mni','mno','moh','mon','mos','mul','mun','mus','mwl','mwr','myn','myv','nah','nai','nap','nau','nav','nbl','nde','ndo','nds','nep','new','nia','nia','nic','niu','nno','nob','nog','non','nor','nqo','nso','nub','nwc','nya','nym','nyn','nyo','nzi','oci','oji','ori','orm','osa','oss','ota','oto','paa','pag','pal','pam','pan','pap','pau','peo','per','phi','phn','pli','pol','pon','por','pra','pro','pus','qaa-qtz','que','raj','rap','rar','roa','roh','rom','rum','run','rup','rus','sad','sag','sah','sai','sal','sam','san','sas','sat','scn','sco','sel','sem','sga','sgn','shn','sid','sin','sio','sit','sla','slo','slv','sma','sme','smi','smj','smn','smo','sms','sna','snd','snk','sog','som','son','sot','spa','srd','srn','srp','srr','ssa','ssw','suk','sun','sus','sux','swa','swe','syc','syr','tah','tai','tam','tat','tel','tem','ter','tet','tgk','tgl','tha','tib','tig','tir','tiv','tkl','tlh','tli','tmh','tog','ton','tpi','tsi','tsn','tso','tuk','tum','tup','tur','tut','tvl','twi','tyv','udm','uga','uig','ukr','umb','und','urd','uzb','vai','ven','vie','vol','vot','wak','wal','war','was','wel','wen','wln','wol','xal','xho','yao','yap','yid','yor','ypk','zap','zbl','zen','zha','znd','zul','zun','zxx','zza')
									let $messages :=    
										if (not($recordsToInspect)) then ()
										else
										(for $record in $recordsToInspect    
										 let $rid := $record/gmd:fileIdentifier/*/text()
										 let $languageCodes := $record/gmd:language/gmd:LanguageCode	 
										 return
										 if (not($languageCodes)) then
											local:addMessage('TR.noLanguageCode',  map { 'filename': local:filename($record), 'id': $rid })
										 else 
											let $wrongCodeValues := $languageCodes/@codeListValue[not(. = $codes)]
											return
											if ($wrongCodeValues) then
											local:addMessage('TR.invalidLanguageCode',  map { 'filename': local:filename($record), 'id': $rid, 'invalidCodes' : string-join($wrongCodeValues,', ') })
											else ()     
										)[position() le $limitErrors]
									return
									(if ($messages) then 'FAILED' else 'PASSED',
									 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
									 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noLanguageCode"/>
										<translationTemplate ref="TR.invalidLanguageCode"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDead447bf-7ace-4b13-b9b1-a80f8566c9cb">
										<label>md common req C.6: Metadata Point of Contact</label>
										<description><![CDATA[<p>Test that the description of the organisation responsible for the creation and maintenance of the metadata is provided.</p>
										<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/md-point-of-contact" target="_blank">Metadata Point of Contact</a></p>]]></description>
										<parent ref="EID61e80506-c181-11e8-a355-529269fb1459"/>
										<expectedResult>NOT_APPLICABLE</expectedResult>
										<expression>
	let $messages := 
		(for $record in $records
		 let $rid := $record/gmd:fileIdentifier/*/text()
		 let $pocs := $record/gmd:contact/* (: At least one gmd:contact is required - the XML Schema validation checks whether this condition is met. :)
		 return
		 if (some $poc in $pocs satisfies (not($poc/gmd:role/*) or not($poc/gmd:role/*/@codeListValue = 'pointOfContact'))) then
			local:addMessage('TR.noMetadataContactRole', map { 'filename': local:filename($record), 'id': $rid, 'pocs': fn:string-join($pocs/gmd:role/*/@codeListValue,', ') })
		 else ()
		)[position() le $limitErrors]
	return
	(if ($messages) then 'FAILED' else 'PASSED',
	 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
	 $messages)
								  		</expression>
										<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
										<translationTemplates>
											<translationTemplate ref="TR.missingElement"/>
											<translationTemplate ref="TR.noMetadataContactRole"/>
											<translationTemplate ref="TR.recordsWithErrors"/>
										</translationTemplates>
									</TestAssertion>
	      						<TestAssertion id="EID0b6c9678-31d1-4c7a-8183-6a4f4da60017">
									<label>md common req C.7: Metadata Date</label>
									<description><![CDATA[<p>Test that the document indicates the date when the metadata record was created or updated.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/md-date" target="_blank">Metadata Date</a></p>]]></description>
									<parent ref="EID61e80506-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := ('dataset', 'series', 'service')
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = $levels]
let $messages := 	
	(for $record in $recordsToInspect
		let $countMetadataDate := count($record/*/gmd:dateStamp)
		let $rid := $record/gmd:dateStamp/*/text()
		return
		if (($countMetadataDate &gt; 0)) then
			local:addMessage('TR.oneDateStamp', map { 'filename': local:filename($record), 'id': $rid })
		else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.oneDateStamp"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
							</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID61e80286-c181-11e8-a355-529269fb1459">
					<label>Identification</label>
					<description>Execute tests that apply for all metadata records on elements that are child elements of the section of the XML document: Identification Info (property of the gmd:MD_Metadata element). This section contains information specific to the dataset / dataset series.
					</description>
					<parent ref="EID137a11bc-4f87-4a55-ab71-59d03e6b28da"/>
					<testSteps>
						<TestStep id="EID61e80628-c181-11e8-a355-529269fb1459">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID61e80286-c181-11e8-a355-529269fb1459"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
							

							<TestAssertion id="EID34195fe7-0d77-46bb-b74e-489463cadd2f">
								<label>md common req C.8: Resource Title</label>
								<description><![CDATA[<p>Test that a non-empty title of the described data is provided.</p>
								<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/resource-title" target="_blank">Resource Title</a></p>]]></description>
								<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
								<expectedResult>NOT_APPLICABLE</expectedResult>
								<expression>
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $title := $record/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:title/*[1]
	 return
	 if (not($title)) then
		local:addMessage('TR.noTitle', map { 'filename': local:filename($record), 'id': $rid })
	 else if (string-length(normalize-space($title/text())) = 0) then
		local:addMessage('TR.emptyTitle', map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.noTitle"/>
										<translationTemplate ref="TR.emptyTitle"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID346ca433-1f21-4e4e-8fec-524d24fd6647">
									<label>md common req C.9: Resource Abstract</label>
									<description><![CDATA[<p>Test that a resource abstract is provided.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/resource-abstract" target="_blank">Resource Abstract</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $abstract := $record/gmd:identificationInfo[1]/*/gmd:abstract/*[1]
	 return
	 if (not($abstract)) then
		local:addMessage('TR.noAbstract', map { 'filename': local:filename($record), 'id': $rid })
	 else if (string-length(normalize-space($abstract/text())) = 0) then
		local:addMessage('TR.emptyAbstract', map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noAbstract"/>
										<translationTemplate ref="TR.emptyAbstract"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID87ee2219-2ba5-4a27-91ac-2b3bf5730012">
									<label>md common req C.10: Responsible Organization</label>
									<description><![CDATA[<p>Test that the responsible organization metadata is provided</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/responsible-organisation" target="_blank">Responsible Organization</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $iso19115_CIRoleCode := ('resourceProvider','custodian','owner','user','distributor','originator','pointOfContact','principalInvestigator','processor','publisher','author')
let $regex := '^[a-zA-Z0-9\._%\+-]+@[a-zA-Z0-9\.-]+\.[a-zA-Z]{2,}$'
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $pocs := $record/gmd:contact/* (: At least one gmd:contact is required - the XML Schema validation checks whether this condition is met. :)
	 return
		for $poc in $pocs
		let $organisationName := $poc/gmd:organisationName/*[1]
		let $emails := $poc/gmd:contactInfo/*/gmd:address/*/gmd:electronicMailAddress/*[1]/text()
		return 
		(if (not($organisationName) or string-length(normalize-space($organisationName/text())) = 0) then
			local:addMessage('TR.noMetadataContactOrganisationName', map { 'filename': local:filename($record), 'id': $rid }) else (),
     if (not($poc/gmd:role/*) or not($poc/gmd:role/*/@codeListValue = $iso19115_CIRoleCode)) then
			local:addMessage('TR.noPointOfContactRole', map { 'filename': local:filename($record), 'id': $rid }) else (),
		 if (not($emails)) then
			local:addMessage('TR.noMetadataContactEmailAddress', map { 'filename': local:filename($record), 'id': $rid })
		 else if (some $email in $emails satisfies not(matches($email,$regex))) then
		 	for $email in $emails
		 	where (not(matches($email,$regex)) or string-length($email)=0)
			return
				local:addMessage('TR.invalidMetadataContactEmailAddress', map { 'filename': local:filename($record), 'id': $rid, 'email': $email }) 
		 else ()
		)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noMetadataContactOrganisationName"/>
										<translationTemplate ref="TR.invalidMetadataContactEmailAddress"/>
                    <translationTemplate ref="TR.noPointOfContactRole"/>                   
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID01ae1fe1-1990-4716-ae09-88d1208b408c">
									<label>md common req C.11: Temporal Reference</label>
									<description><![CDATA[<p>Test that there is at least one temporal reference and it is codified correctly.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/temporal-reference" target="_blank">Temporal Reference</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $regex := '^((?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:(?:0[13578]|1[02])(-)31)|((0[1,3-9]|1[0-2])(-)(29|30))))$|^(?:(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(-)02(-)29)$|^(?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:0[1-9])|(?:1[0-2]))(-)(?:0[1-9]|1\d|2[0-8])$'

let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $temporalReferences := $record/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:date/*
	 let $relevantTempRefs := $temporalReferences[gmd:dateType/*/@codeListValue = ('publication','revision','creation')]
	 return
	 (if(not($relevantTempRefs)) then
		local:addMessage('TR.noRelevantDate', map { 'filename': local:filename($record), 'id': $rid })
	 else (for $date in $relevantTempRefs
   return 
   if (not(matches($date/gmd:date/gco:Date/text(),$regex))) then
        local:addMessage('TR.invalidDateFormat', map { 'filename': local:filename($record), 'id': $rid , 'date': $date }) 
   else()))
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.timePeriodWithoutInlineTimeInstant"/>
										<translationTemplate ref="TR.noRelevantDate"/>
                    <translationTemplate ref="TR.invalidDateFormat"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID109cce73-7e80-432e-a3e0-450e231f4120">
									<label>md common req C.12: Max One Date of Creation</label>
									<description><![CDATA[<p>Test that not more than one date of creation for the metadata is given</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/max-1-date-of-creation" target="_blank">Max One Date of Creation</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $regex := '^((?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:(?:0[13578]|1[02])(-)31)|((0[1,3-9]|1[0-2])(-)(29|30))))$|^(?:(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(-)02(-)29)$|^(?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:0[1-9])|(?:1[0-2]))(-)(?:0[1-9]|1\d|2[0-8])$'

let $dt := ('CI_DateTypeCode','http://standards.iso.org/iso/19139/resources/gmxCodelists.xml#CI_DateTypeCode')	
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $temporalReferences := $record/gmd:identificationInfo[1]/*/gmd:citation/gmd:CI_Citation/gmd:date/gmd:CI_Date
	 let $creationTempRefs := $temporalReferences[gmd:dateType/*/@codeListValue = ('creation')]
	 return
 if(count($creationTempRefs) ne 1 and count($creationTempRefs) ne 0) then
		local:addMessage('TR.moreThanOneCreationDate', map { 'filename': local:filename($record), 'id': $rid })
	 else (for $date in $creationTempRefs
   return 
   if (not(matches($date/gmd:date/gco:Date/text(),$regex))) then
        local:addMessage('TR.invalidDateFormat', map { 'filename': local:filename($record), 'id': $rid , 'date': $date }) 
   else())
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.moreThanOneCreationDate"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
                    <translationTemplate ref="TR.invalidDateFormat"/>
									</translationTemplates>
								</TestAssertion>
							
							<TestAssertion id="EID6b4e043c-7624-4b3c-8b0c-bec547d2f8f6">
									<label>md common req C.13: Not More than one Date of Last Revision</label>
									<description><![CDATA[<p>Test that not more than one date of last revision for the metadata is given.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/max-1-date-of-last-revision" target="_blank">Max one Date of Last Revision</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $regex := '^((?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:(?:0[13578]|1[02])(-)31)|((0[1,3-9]|1[0-2])(-)(29|30))))$|^(?:(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(-)02(-)29)$|^(?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:0[1-9])|(?:1[0-2]))(-)(?:0[1-9]|1\d|2[0-8])$'

let $dt := ('CI_DateTypeCode','http://standards.iso.org/iso/19139/resources/gmxCodelists.xml#CI_DateTypeCode')	
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $temporalReferences := $record/gmd:identificationInfo[1]/*/gmd:citation/gmd:CI_Citation/gmd:date/gmd:CI_Date
	 let $revisionTempRefs := $temporalReferences[gmd:dateType/*/@codeListValue = ('revision')]
	 return
 if(count($revisionTempRefs) ne 1 and count($revisionTempRefs) ne 0) then
		local:addMessage('TR.moreThanOneCreationDate', map { 'filename': local:filename($record), 'id': $rid })
	 else (for $date in $revisionTempRefs
   return 
   if (not(matches($date/gmd:date/gco:Date/text(),$regex))) then
        local:addMessage('TR.invalidDateFormat', map { 'filename': local:filename($record), 'id': $rid , 'date': $date }) 
   else())
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.moreThanOneRevisionDate"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
                    <translationTemplate ref="TR.invalidDateFormat"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID76f8fb3a-c00f-11e8-a355-529269fb1459">
									<label>md common req C.14: Temporal Extent</label>
									<description><![CDATA[<p>Test if a temporal reference is provided using the temporary extension. The temporal reference will be coded using an individual date or a period of time between two dates.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/temporal-extent" target="_blank">Temporal Extent</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $timePeriods := $record/gmd:identificationInfo[1]/*/*[self::gmd:extent or self::srv:extent]/*/gmd:temporalElement/*/gmd:extent/*[self::gml:TimePeriod or self::gml31:TimePeriod]
	 let $invalidTimePeriods := 
		for $timePeriod in $timePeriods
		return
		if (not($timePeriod[(not(*:begin) or *:begin/*:TimeInstant) and (not(*:end) or *:end/*:TimeInstant)])) then $timePeriod
		else ()
	 return
	 if ($invalidTimePeriods) then
		local:addMessage('TR.timePeriodWithoutInlineTimeInstant', map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.timePeriodWithoutInlineTimeInstant"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID76f8ff36-c00f-11e8-a355-529269fb1459">
									<label>md common req C.15: Keyword Originating CV</label>
									<description><![CDATA[<p>Test that the citation of the source controlled vocabulary when giving the value of a keyword is provided correctly.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/keyword-originating-cv" target="_blank">Keyword Originating CV</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $regex := '^((?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:(?:0[13578]|1[02])(-)31)|((0[1,3-9]|1[0-2])(-)(29|30))))$|^(?:(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(-)02(-)29)$|^(?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:0[1-9])|(?:1[0-2]))(-)(?:0[1-9]|1\d|2[0-8])$'

let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $thesauri := $record/gmd:identificationInfo[1]/*/gmd:descriptiveKeywords/*/gmd:thesaurusName
	 return
	 if (not($thesauri)) then ()
	 else for $thesaurus in $thesauri
		let $title := $thesaurus/*/gmd:title/*[1]/text()
    let $date := $thesaurus/gmd:CI_Citation/gmd:date/*
		let $hasExpectedDate := ($thesaurus/*/gmd:date/*[gmd:date/*/text() and gmd:dateType/*/@codeListValue = ('publication')])
		return
		(if (not($title)) then local:addMessage('TR.noTitleForThesaurus', map { 'filename': local:filename($record), 'id': $rid}) 
		 else if (string-length(normalize-space($title)) = 0) then
     local:addMessage('TR.emptyTitleForThesaurus', map { 'filename': local:filename($record), 'id': $rid})
		 else (),
		 if (not($hasExpectedDate)) then 
       local:addMessage('TR.invalidDateForThesaurus', map { 'filename': local:filename($record), 'id': $rid, 'thesaurus': if ($title) then $title else ''}) 
      else()
		)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noTitleForThesaurus"/>
										<translationTemplate ref="TR.emptyTitleForThesaurus"/>
										<translationTemplate ref="TR.invalidDateForThesaurus"/>
                    <translationTemplate ref="TR.invalidDateFormat"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID76f901ca-c00f-11e8-a355-529269fb1459">
									<label>md common req C.16: Group Keywords by CV</label>
									<description><![CDATA[<p>Test that a Keywords element only contain keywords originating from the one cited controlled vocabulary, or its version.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/group-keywords-by-cv" target="_blank">Group Keywords by CV</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $keywords := $record/gmd:identificationInfo[1]/*/gmd:descriptiveKeywords/*
	 return
	 (if (not($keywords)) then
		local:addMessage('TR.noKeywords', map { 'filename': local:filename($record), 'id': $rid })
	 else if ($keywords[string-length(normalize-space(text())) = 0]) then ('PASSED')
	 else local:addMessage('TR.emptyKeywords', map { 'filename': local:filename($record), 'id': $rid }))
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED MANUAL',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.noKeywords"/>
										<translationTemplate ref="TR.emptyKeywords"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EIDf7e5c9d6-7a5c-47cc-9c95-1d4f3a5f92eb">
									<label>md common req C.17: Limitations on Public Access</label>
									<description><![CDATA[<p>Test that information on the existence of some limitation of public access to spatial data sets and spatial data services is provided.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/limitations-on-public-access" target="_blank">Limitations on Public Access</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $resourceConstraints := $record/gmd:identificationInfo/*/gmd:resourceConstraints/gmd:MD_LegalConstraints
	 let $validConstraints := 
		for $resCon in $resourceConstraints
			let $oneValidAccessConstraint := 
				if ($resCon[/gmd:accessConstraints/gmd:MD_RestrictionCode/@codeListValue ='otherRestrictions'] and $resCon[./gmd:otherConstraints/gmx:Anchor/@xlink:href='http://inspire.ec.europa.eu/metadata-codelist/LimitationsOnPublicAccess/INSPIRE_Directive_Article13_1a']) then true()
       	else false()
			return 
			if ($oneValidAccessConstraint) then $resCon else ()
	 return
	 if ($validConstraints) then ()
	 else local:addMessage('TR.noValidResourceConstraint', map { 'filename': local:filename($record), 'id': $rid })
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noValidResourceConstraint"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID410b57a6-0314-4506-9352-19042f1723cd">
									<label>md common req C.18: Conditions for Access and Use</label>
									<description><![CDATA[<p>Test the technical restrictions of access and use of spatial data sets and services.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/conditions-for-access-and-use" target="_blank">Conditions for Access and Use</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $iso19115_MD_ClassificationCode := ('unclassified','restricted','confidential','secret','topSecret')
let $iso19115_MD_RestrictionCode_without_otherRestrictions := ('copyright','patent','patentPending','trademark','license','intellectualPropertyRights','restricted')
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $resourceConstraints := $record/gmd:identificationInfo/*/gmd:resourceConstraints/*
	 let $validConstraints := 
		for $resCon in $resourceConstraints
    
			let $oneValidAccessConstraint := 
				if ($resCon[gmd:accessConstraints/gmd:MD_RestrictionCode/@codeListValue ='otherRestrictions' and string-length(normalize-space(fn:string-join(gmd:otherConstraints/*/text(),', '))) &gt; 0]) then 						true()
				else if($resCon/gmd:accessConstraints/gmd:MD_RestrictionCode[@codeListValue = $iso19115_MD_RestrictionCode_without_otherRestrictions]) then true()
				else false()
			
      let $oneValidUseConstraint := 
				if ($resCon[gmd:useConstraints/gmd:MD_RestrictionCode/@codeListValue ='otherRestrictions' and string-length(normalize-space(fn:string-join(gmd:otherConstraints/*/text(),', '))) &gt; 0]) then 						true()
				else if($resCon/gmd:useConstraints/gmd:MD_RestrictionCode[@codeListValue = $iso19115_MD_RestrictionCode_without_otherRestrictions]) then true()
				else false()
      
      let $oneValidConstraint := 
      if (not($oneValidUseConstraint) and not($oneValidAccessConstraint)) then
        if($resCon[./gmd:otherConstraints/*/text()='noConditionsApply' or ./gmd:otherConstraints/*/text()='conditionsUnknown']) then 
          true()
       	else false()
      else false()
      
      let $oneValidClassification := boolean($resCon/gmd:classification/gmd:MD_ClassificationCode[@codeListValue = $iso19115_MD_ClassificationCode])
			return
      
			if (($oneValidAccessConstraint or $oneValidUseConstraint) and $oneValidConstraint and $oneValidClassification) then $resCon else ()
	 return
	 if ($validConstraints) then ()
	 else local:addMessage('TR.noValidResourceConstraint', map { 'filename': local:filename($record), 'id': $rid })
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noValidResourceConstraint"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID701be21b-1158-4055-9594-67a4e2005e38">
									<label>md common req C.19: Geographical Bounding Box</label>
									<description><![CDATA[<p>Test that the extent of the resource in the geographic space is specified using a geometric bounding box.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/bounding-box" target="_blank">Bounding Box</a></p>]]></description>
									<parent ref="EID61e80628-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $values := ('dataset', 'series')
let $regex := '^-?\d+\.\d{2,}'
let $recordsWithErrors := $records[not(gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = $values)]
let $recordsToInspect := $records[gmd:hierarchyLevel/*/@codeListValue = $values]
let $messages := 
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/gco:CharacterString/text()
	 let $bboxes := $record/gmd:identificationInfo[1]/*/gmd:extent/*/gmd:geographicElement/gmd:EX_GeographicBoundingBox
	 return
	 if (not($bboxes)) then
		local:addMessage('TR.noGeographicBoundingBox', map { 'filename': local:filename($record), 'id': $rid })
	 else
		let $invalidbboxes :=
			for $bbox in $bboxes
			let $west := $bbox/gmd:westBoundLongitude/*/text()
			let $east := $bbox/gmd:eastBoundLongitude/*/text()
			let $south := $bbox/gmd:southBoundLatitude/*/text()
			let $north := $bbox/gmd:northBoundLatitude/*/text() 
			return     
			if (($west and matches($west,$regex) and fn:number($west) &gt;= -180 and fn:number($west) &lt;= 180) and
				 ($east and matches($east,$regex) and fn:number($east) &gt;= -180 and fn:number($east) &lt;= 180) and
				 ($south and matches($south,$regex) and fn:number($south) &gt;= -90 and fn:number($south) &lt;= 90) and
				 ($north and matches($north,$regex) and fn:number($north) &gt;= -90 and fn:number($north) &lt;= 90) and
				 (fn:number($south) &lt;= fn:number($north))
				) then ()
			else $bbox
		return
		if ($invalidbboxes) then
			for $bbox in $invalidbboxes
			let $west := $bbox/gmd:westBoundLongitude/*/text()
			let $east := $bbox/gmd:eastBoundLongitude/*/text()
			let $south := $bbox/gmd:southBoundLatitude/*/text()
			let $north := $bbox/gmd:northBoundLatitude/*/text() 
			return
			local:addMessage('TR.invalidGeographicBoundingBox', map { 'filename': local:filename($record), 'id': $rid, 'west': $west, 'east': $east, 'south': $south, 'north': $north })
		else ()
	)[position() le $limitErrors]
return
(
  if ($messages//@ref = ('TR.noGeographicBoundingBox','TR.invalidGeographicBoundingBox')) then 'FAILED'
  else if ($recordsWithErrors) then 'FAILED'
  else if ($recordsToInspect) then 'PASSED_MANUAL'
  else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.noGeographicBoundingBox"/>
										<translationTemplate ref="TR.invalidGeographicBoundingBox"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
							</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID61e803d0-c181-11e8-a355-529269fb1459">
					<label>Data quality</label>
					<description> Execute tests that apply for all metadata records on elements that are child 
					elements of the section of the XML document: Data Quality Information (property of the gmd:MD_Metadata element). 
					This section contains information specific to the quality and lineage (including processing steps and sources) of the 
					resource.
					</description>
					<parent ref="EID137a11bc-4f87-4a55-ab71-59d03e6b28da"/>
					<testSteps>
						<TestStep id="EID61e80a06-c181-11e8-a355-529269fb1459">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID61e803d0-c181-11e8-a355-529269fb1459"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
							<TestAssertion id="EIDf55f2448-c4d5-4af0-a83b-40ccd0d2a7df">
									<label>md common req C.20: Dataset Conformity</label>
									<description><![CDATA[<p>Test that the metadata includes information on the degree of conformity with the implementing rules on interoperability of spatial data sets.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/conformity" target="_blank">Dataset Conformity</a></p>]]></description>
									<parent ref="EID61e80a06-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := ('dataset', 'series', 'service')
let $recordsToInspect := $records[gmd:hierarchyLevel/*/@codeListValue = $levels]
let $messages := 
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $confResPasses := $record/gmd:dataQualityInfo/*/gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:pass
	 return 
	 if (not($confResPasses)) then
		local:addMessage('TR.noConformityStatement', map { 'filename': local:filename($record), 'id': $rid })
	 else
		for $confResPass in $confResPasses
		return
		if (not($confResPass/*) and not($confResPass/@gco:nilReason = 'unknown')) then
			local:addMessage('TR.declareNoConformityEvaluationAsUnknown', map { 'filename': local:filename($record), 'id': $rid })
		else () (: Schema validation will ensure that the content of $confResPass is a gco:Boolean with boolean value :)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.declareNoConformityEvaluationAsUnknown"/>
										<translationTemplate ref="TR.noConformityStatement"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID1f9ddbc5-679b-44b0-bd6f-db14c9c348a9">
									<label>md common req C.21: Dataset Conformity Specifications</label>
									<description><![CDATA[<p>Test that the DQ_ConformanceResult element is correctly specified through a citation of the INSPIRE Implementing Rule and a specification document or Conformance Class using CI_Citation element: including its official title and the date of publication of the document.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/conformity-specification" target="_blank">Dataset Conformity Specifications</a></p>]]></description>
									<parent ref="EID61e80a06-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $regex := '^((?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:(?:0[13578]|1[02])(-)31)|((0[1,3-9]|1[0-2])(-)(29|30))))$|^(?:(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(-)02(-)29)$|^(?:(?:1[6-9]|2[0-9])\d{2})(-)(?:(?:0[1-9])|(?:1[0-2]))(-)(?:0[1-9]|1\d|2[0-8])$'
let $messages := 
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $specifications := $record/gmd:dataQualityInfo/*/gmd:report/*/gmd:result/*/gmd:specification
	 return 
	 if (not($specifications)) then () (: Only failure situations are reported, no warnings :)
	 else
	 for $spec in $specifications
		return
		(if (not($spec/gmd:CI_Citation/gmd:title/*[1][string-length(normalize-space(text())) &gt; 0])) then
			local:addMessage('TR.noTitleForSpecification', map { 'filename': local:filename($record), 'id': $rid })
		else if (not($spec/gmd:CI_Citation/gmd:date/*/gmd:dateType/*[@codeListValue = ('publication')])) then
			local:addMessage('TR.noDateTypeForSpecification', map { 'filename': local:filename($record), 'id': $rid, 'specification':  $spec/gmd:CI_Citation/gmd:title/*[1]/text() })
    else if ($spec/gmd:CI_Citation/gmd:date/*/gmd:dateType/*[@codeListValue = ('publication')]) then
      if (not(matches($spec/*/gmd:date/gmd:CI_Date/gmd:date/*/text(),$regex))) then
        local:addMessage('TR.invalidDateFormat', map { 'filename': local:filename($record), 'id': $rid}) else()
		else if (not($spec/ancestor::gmd:DQ_DomainConsistency)) then
			local:addMessage('TR.noDQDomainConsistencyParent', map { 'filename': local:filename($record), 'id': $rid, 'specification':  $spec/gmd:CI_Citation/gmd:title/*[1]/text() })
		else ())
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noDQDomainConsistencyParent"/>
										<translationTemplate ref="TR.noDateTypeForSpecification"/>
										<translationTemplate ref="TR.noTitleForSpecification"/>
										<translationTemplate ref="TR.invalidDateFormat"/>            
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							<TestAssertion id="EID614cd750-a8a2-4256-908c-e452c2b4e506">
									<label>md common req C.22: Conformity Degree</label>
									<description><![CDATA[<p>Test that each Conformance Result includes the degree of declared conformity against this specification using a property with value "true" for a conformant resource and "false" for non-conformant resource.</p>
									<p>More information: <a href="http://inspire.ec.europa.eu/id/ats/metadata/2.0/common/conformity-degree" target="_blank">Conformity Degree</a></p>]]></description>
									<parent ref="EID61e80a06-c181-11e8-a355-529269fb1459"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := ('dataset', 'series', 'service')
let $recordsToInspect := $records[gmd:hierarchyLevel/*/@codeListValue = $levels]
let $messages := 
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $confResPasses := $record/gmd:dataQualityInfo/*/gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:pass
	 return 
	 if (not($confResPasses)) then
		local:addMessage('TR.noConformityStatement', map { 'filename': local:filename($record), 'id': $rid })
	 else
		for $confResPass in $confResPasses
		return
		if (not($confResPass/*) and not($confResPass/@gco:nilReason = 'unknown') and not($confResPass/gco:Boolean)) then
			local:addMessage('TR.declareNoConformityEvaluationAsUnknown', map { 'filename': local:filename($record), 'id': $rid })
   else if (($confResPass/gco:Boolean) and not($confResPass/gco:Boolean/text()='true' or $confResPass/gco:Boolean/text()='false')) then
			local:addMessage('TR.declareNoConformityEvaluationAsUnknown', map { 'filename': local:filename($record), 'id': $rid })
		else () (: Schema validation will ensure that the content of $confResPass is a gco:Boolean with boolean value :)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  		</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.declareNoConformityEvaluationAsUnknown"/>
										<translationTemplate ref="TR.noConformityStatement"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							
							</testAssertions>
							</TestStep>
					</testSteps>
				</TestCase>
			</testCases>
		</TestModule>
	</testModules>
</ExecutableTestSuite>
